Examples based on microtask and macrotasks

 âœ… Example 1

console.log('A');
setTimeout(() => {
  console.log('B');
}, 0);
Promise.resolve().then(() => {
  console.log('C');
});
console.log('D');


Output:


A
D
C
B



 âœ… Example 2

console.log(1);
setTimeout(() => {
  console.log(2);
}, 0);
Promise.resolve().then(() => {
  console.log(3);
});
console.log(4);


Output:


1
4
3
2



 âœ… Example 3

Promise.resolve().then(() => {
  console.log('First');
});
console.log('Second');
setTimeout(() => {
  console.log('Third');
}, 0);
console.log('Fourth');


Output:


Second
Fourth
First
Third



 âœ… Example 4

setTimeout(() => {
  console.log('setTimeout');
}, 0);
Promise.resolve().then(() => {
  console.log('promise');
});
queueMicrotask(() => {
  console.log('microtask');
});
console.log('sync');


Output:


sync
promise
microtask
setTimeout


> ðŸ’¡ `Promise.then` and `queueMicrotask` are both microtasks, executed in order after sync code.


 âœ… Example 5

console.log('one');
setTimeout(() => {
  console.log('two');
}, 0);
Promise.resolve().then(() => {
  console.log('three');
}).then(() => {
  console.log('four');
});
console.log('five');


Output:


one
five
three
four
two



 âœ… Example 6

setTimeout(() => {
  console.log('A');
}, 1000);
setTimeout(() => {
  console.log('B');
}, 0);
Promise.resolve().then(() => {
  console.log('C');
});
Promise.resolve().then(() => {
  console.log('D');
});


Output:


C
D
A
B



 âœ… Example 7

Promise.resolve().then(() => {
  console.log('Promise 1');
  return Promise.resolve('Inner');
}).then((val) => {
  console.log(val);
});
console.log('Sync');

Output:


Sync
Promise 1
Inner



 âœ… Example 8

setTimeout(() => {
  console.log('timeout 1');
}, 0);
Promise.resolve().then(() => {
  console.log('promise 2');
});
setTimeout(() => {
  console.log('timeout 2');
}, 0);
Promise.resolve().then(() => {
  console.log('promise 1');
});


Output:


promise 2
promise 1
timeout 1
timeout 2



 âœ… Example 9

console.log('Start');

queueMicrotask(() => {
  console.log('Microtask 1');
});
Promise.resolve().then(() => {
  console.log('Promise then');
});
console.log('End');


Output:


Start
End
Microtask 1
Promise then



 âœ… Example 10

console.log('Start');
setTimeout(() => {
  console.log('Timeout');
}, 0);
Promise.resolve().then(() => {
  console.log('Promise');
});
queueMicrotask(() => {
  console.log('Microtask');
});
console.log('End');


Output:


Start
End
Promise
Microtask
Timeout



ðŸ”¥ Example 11 â€“ Nested Promises & Microtask inside `then`

console.log('1');

Promise.resolve().then(() => {
  console.log('2');
  queueMicrotask(() => {
    console.log('3');
  });
  return Promise.resolve();
}).then(() => {
  console.log('4');
});

console.log('5');


 âœ… Output:


1
5
2
3
4


 ðŸ§  Why?

 `1`, `5` â†’ sync
 `2` â†’ first microtask
 `queueMicrotask(...)` is scheduled during `2`, runs after
 `4` â†’ chained `.then()`
 `3` â†’ finally, `queueMicrotask`



ðŸ”¥ Example 12 â€“ Microtask inside a Macrotask

console.log('A');
setTimeout(() => {
  console.log('B');
  queueMicrotask(() => {
    console.log('C');
  });
  Promise.resolve().then(() => {
    console.log('D');
  });
  console.log('E');
}, 0);
console.log('F');


 âœ… Output:


A
F
B
E
C
D


 ðŸ§  Why?

 `A`, `F` â†’ sync
 `setTimeout(...)` callback starts â†’ logs `B`, `E`
 Inside that callback:

   `.then(...)` & `queueMicrotask()` go into microtask queue
 `D`, `C` â†’ microtasks from within macrotask



ðŸ”¥ Example 13 â€“ Mixed chaining & nested microtasks

console.log('start');
Promise.resolve().then(() => {
  console.log('promise 1');
  queueMicrotask(() => {
    console.log('microtask 1');
  });
  return Promise.resolve('inner');
}).then((val) => {
  console.log(val);
  queueMicrotask(() => {
    console.log('microtask 2');
  });
});
console.log('end');


 âœ… Output:


start
end
promise 1
microtask 1
inner
microtask 2




ðŸ”¥ Example 14 â€“ Recursive microtasks

console.log('X');
queueMicrotask(() => {
  console.log('Y');
  queueMicrotask(() => {
    console.log('Z');
  });
});
console.log('W');


 âœ… Output:


X
W
Y
Z


 ðŸ§  Explanation:

 Microtasks can enqueue other microtasks, but they won't interrupt current ones â€” theyâ€™ll run in the next microtask cycle.



ðŸ”¥ Example 15 â€“ Macrotask enqueues microtask which enqueues another microtask

setTimeout(() => {
  console.log('1');
  queueMicrotask(() => {
    console.log('2');
    queueMicrotask(() => {
      console.log('3');
    });
  });
  console.log('4');
}, 0);
console.log('5');


 âœ… Output:


5
1
4
2
3




ðŸ”¥ Example 16 â€“ Promise inside microtask

queueMicrotask(() => {
  console.log('A');

  Promise.resolve().then(() => {
    console.log('B');
  });

  console.log('C');
});

console.log('D');


 âœ… Output:


D
A
C
B




ðŸ”¥ Example 17 â€“ Microtask chain explosion

console.log('start');

Promise.resolve().then(() => {
  console.log('1');
  return Promise.resolve().then(() => {
    console.log('2');
  });
}).then(() => {
  console.log('3');
});

console.log('end');


 âœ… Output:


start
end
1
2
3




ðŸ”¥ Example 18 â€“ Microtask > Macrotask even when deeply nested

setTimeout(() => {
  console.log('T1');
}, 0);
Promise.resolve().then(() => {
  console.log('P1');
  setTimeout(() => {
    console.log('T2');
  }, 0);
  return Promise.resolve().then(() => {
    console.log('P2');
  });
}).then(() => {
  console.log('P3');
});
console.log('S');


 âœ… Output:


S
P1
P2
P3
T1
T2




ðŸ”¥ Example 19 â€“ `queueMicrotask` inside `.then` vs direct

Promise.resolve().then(() => {
  console.log('A');
  queueMicrotask(() => {
    console.log('B');
  });
});
queueMicrotask(() => {
  console.log('C');
});
console.log('D');


 âœ… Output:


D
A
C
B